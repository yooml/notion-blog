<!DOCTYPE HTML>
<html>

<head>

<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPad 2.0">
<title>The Portable Executable File Format - Abstract</title>
</head>

<body bgcolor="#FFFFFF">

<h1><font size="2" face="ARIAL"><b>The Portable Executable File
Format</b></font></h1>

<h2><font size="2" face="ARIAL"><b>Abstract</b></font></h2>

<p><font size="2" face="ARIAL">The Windows NT&trade; version 3.1
operating system introduces a new executable file format called
the Portable Executable (PE) file format. </font></p>

<h2><font size="2" face="ARIAL">Introduction</font></h2>

<p><font size="2" face="ARIAL">The recent addition of the
Microsoft速 Windows NT&trade; operating system to the family of
Windows&trade; operating systems brought many changes to the
development environment and more than a few changes to
applications themselves. One of the more significant changes is
the introduction of the Portable Executable (PE) file format. The
new PE file format draws primarily from the COFF (Common Object
File Format) specification that is common to UNIX速 operating
systems. Yet, to remain compatible with previous versions of the
MS-DOS速 and Windows operating systems, the PE file format also
retains the old familiar MZ header from MS-DOS.</font></p>

<p><font size="2" face="ARIAL">This article discusses each of the
components of the file as they occur when you traverse the file's
contents, starting at the top and working your way down through
the file.</font></p>

<p><font size="2" face="ARIAL">Much of the definition of
individual file components comes from the file WINNT.H, a file
included in the Microsoft Win32&trade; Software Development Kit
(SDK) for Windows NT. In it you will find structure type
definitions for each of the file headers and data directories
used to represent various components in the file. In other places
in the file, WINNT.H lacks sufficient definition of the file
structure. </font></p>

<p><font size="2" face="ARIAL">The PE file format for Windows NT
introduces a completely new structure to developers familiar with
the Windows and MS-DOS environments. Yet developers familiar with
the UNIX environment will find that the PE file format is similar
to, if not based on, the COFF specification.</font></p>

<p><font size="2" face="ARIAL">The entire format consists of an
MS-DOS MZ header, followed by a real-mode stub program, the PE
file signature, the PE file header, the PE optional header, all
of the section headers, and finally, all of the section bodies.</font></p>

<p><font size="2" face="ARIAL">The optional header ends with an
array of data directory entries that are relative virtual
addresses to data directories contained within section bodies.
Each data directory indicates how a specific section body's data
is structured.</font></p>

<p><font size="2" face="ARIAL">The PE file format has eleven
predefined sections, as is common to applications for Windows NT,
but each application can define its own unique sections for code
and data.</font></p>

<p><font size="2" face="ARIAL">The .debug predefined section also
has the capability of being stripped from the file into a
separate debug file. If so, a special debug header is used to
parse the debug file, and a flag is specified in the PE file
header to indicate that the debug data has been stripped.</font></p>

<h2><font size="2" face="ARIAL">Structure of PE Files</font></h2>

<p><font size="2" face="ARIAL">The PE file format is organized as
a linear stream of data. It begins with an MS-DOS header, a
real-mode program stub, and a PE file signature. Immediately
following is a PE file header and optional header. Beyond that,
all the section headers appear, followed by all of the section
bodies. Closing out the file are a few other regions of
miscellaneous information, including relocation information,
symbol table information, line number information, and string
table data. All of this is more easily absorbed by looking at it
graphically, as shown in Figure 1.</font></p>

<p><font size="2" face="ARIAL"><img src="pef2034b.gif" alt="Pe File Format  6737 bytes ]" width="255" height="812"></font></p>

<p><font size="2" face="ARIAL"><b>Figure 1. Structure of a
Portable Executable file image</b></font></p>

<p><font size="2" face="ARIAL">Starting with the MS-DOS file
header structure, each of the components in the PE file format is
discussed below in the order in which it occurs in the file.</font></p>

<h2><font size="2" face="ARIAL">MS-DOS/Real-Mode Header</font></h2>

<p><font size="2" face="ARIAL">As mentioned above, the first
component in the PE file format is the MS-DOS header. The MS-DOS
header is not new for the PE file format. It is the same MS-DOS
header that has been around since version 2 of the MS-DOS
operating system. The main reason for keeping the same structure
intact at the beginning of the PE file format is so that, when
you attempt to load a file created under Windows version 3.1 or
earlier, or MS DOS version 2.0 or later, the operating system can
read the file and understand that it is not compatible. In other
words, when you attempt to run a Windows NT executable on MS-DOS
version 6.0, you get this message: &quot;This program cannot be
run in DOS mode.&quot; If the MS-DOS header was not included as
the first part of the PE file format, the operating system would
simply fail the attempt to load the file and offer something
completely useless, such as: &quot;The name specified is not
recognized as an internal or external command, operable program
or batch file.&quot;</font></p>

<p><font size="2" face="ARIAL">The MS-DOS header occupies the
first 64 bytes of the PE file. A structure representing its
content is described below:</font></p>

<p><font size="2" face="ARIAL"><b>WINNT.H</b></font></p>

<pre><font size="2" face="COURIER">typedef struct _IMAGE_DOS_HEADER {  // DOS .EXE header
    USHORT e_magic;         // Magic number
    USHORT e_cblp;          // Bytes on last page of file
    USHORT e_cp;            // Pages in file
    USHORT e_crlc;          // Relocations
    USHORT e_cparhdr;       // Size of header in paragraphs
    USHORT e_minalloc;      // Minimum extra paragraphs needed
    USHORT e_maxalloc;      // Maximum extra paragraphs needed
    USHORT e_ss;            // Initial (relative) SS value
    USHORT e_sp;            // Initial SP value
    USHORT e_csum;          // Checksum
    USHORT e_ip;            // Initial IP value
    USHORT e_cs;            // Initial (relative) CS value
    USHORT e_lfarlc;        // File address of relocation table
    USHORT e_ovno;          // Overlay number
    USHORT e_res[4];        // Reserved words
    USHORT e_oemid;         // OEM identifier (for e_oeminfo)
    USHORT e_oeminfo;       // OEM information; e_oemid specific
    USHORT e_res2[10];      // Reserved words
    LONG   e_lfanew;        // File address of new exe header
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
</font></pre>

<p><font size="2" face="ARIAL">The first field, <b>e_magic</b>,
is the so-called magic number. This field is used to identify an
MS-DOS-compatible file type. All MS-DOS-compatible executable
files set this value to 0x54AD, which represents the ASCII
characters <i>MZ</i>. MS-DOS headers are sometimes referred to as
MZ headers for this reason. Many other fields are important to
MS-DOS operating systems, but for Windows NT, there is really one
more important field in this structure. The final field, <b>e_lfanew</b>,
is a 4-byte offset into the file where the PE file header is
located. It is necessary to use this offset to locate the PE
header in the file. For PE files in Windows NT, the PE file
header occurs soon after the MS-DOS header with only the
real-mode stub program between them.</font></p>

<h3><font size="2" face="ARIAL">Real-Mode Stub Program</font></h3>

<p><font size="2" face="ARIAL">The real-mode stub program is an
actual program run by MS-DOS when the executable is loaded. For
an actual MS-DOS executable image file, the application begins
executing here. For successive operating systems, including
Windows, OS/2速, and Windows NT, an MS-DOS stub program is placed
here that runs instead of the actual application. The programs
typically do no more than output a line of text, such as:
&quot;This program requires Microsoft Windows v3.1 or
greater.&quot; Of course, whoever creates the application is able
to place any stub they like here, meaning you may often see such
things as: &quot;You can't run a Windows NT application on OS/2,
it's simply not possible.&quot;</font></p>

<p><font size="2" face="ARIAL">When building an application for
Windows version 3.1, the linker links a default stub program
called WINSTUB.EXE into your executable. You can override the
default linker behavior by substituting your own valid
MS-DOS-based program in place of WINSTUB and indicating this to
the linker with the <b>STUB</b> module definition statement.
Applications developed for Windows NT can do the same thing by
using the <b>-STUB: linker</b> option when linking the executable
file.</font></p>

<h2><font size="2" face="ARIAL">PE File Header and Signature</font></h2>

<p><font size="2" face="ARIAL">The PE file header is lo cated by
indexing the <b>e_lfanew</b> field of the MS-DOS header. The <b>e_lfanew</b>
field simply gives the offset in the file, so add the file's
memory-mapped base address to determine the actual memory-mapped
address</font></p>

<pre><font size="2" face="COURIER">#define NTSIGNATURE(a) ((LPVOID)((BYTE *)a +    \
                        ((PIMAGE_DOS_HEADER)a)-&gt;e_lfanew))
</font></pre>

<p><font size="2" face="ARIAL">When manipulating PE file
information, I found that there were several locations in the
file that I needed to refer to often. Since these locations are
merely offsets into the file, it is easier to implement these
locations as macros because they provide much better performance
than functions do.</font></p>

<p><font size="2" face="ARIAL">Notice that instead of retrieving
the offset of the PE file header, this macro retrieves the
location of the PE file signature. Starting with Windows and OS/2
executables, .EXE files were given file signatures to specify the
intended target operating system. For the PE file format in
Windows NT, this signature occurs immediately before the PE file
header structure. In versions of Windows and OS/2, the signature
is the first word of the file header. Also, for the PE file
format, Windows NT uses a DWORD for the signature. </font></p>

<p><font size="2" face="ARIAL">The macro presented above returns
the offset of where the file signature appears, regardless of
which type of executable file it is. So depending on whether it's
a Windows NT file signature or not, the file header exists either
after the signature DWORD or at the signature WORD. </font></p>

<pre><font size="2" face="COURIER">DWORD  WINAPI ImageFileType (
    LPVOID    lpFile)
{
    /* DOS file signature comes first. */
    if (*(USHORT *)lpFile == IMAGE_DOS_SIGNATURE)
        {
        /* Determine location of PE File header from
           DOS header. */
        if (LOWORD (*(DWORD *)NTSIGNATURE (lpFile)) ==
                                IMAGE_OS2_SIGNATURE ||
            LOWORD (*(DWORD *)NTSIGNATURE (lpFile)) ==
                             IMAGE_OS2_SIGNATURE_LE)
            return (DWORD)LOWORD(*(DWORD *)NTSIGNATURE (lpFile));

        else if (*(DWORD *)NTSIGNATURE (lpFile) ==
                            IMAGE_NT_SIGNATURE)
            return IMAGE_NT_SIGNATURE;

        else
            return IMAGE_DOS_SIGNATURE;
        }

    else
        /* unknown file type */
        return 0;
}
</font></pre>

<p><font size="2" face="ARIAL">The code listed above quickly
shows how useful the <b>NTSIGNATURE</b> macro becomes. The macro
makes it easy to compare the different file types and return the
appropriate one for a given type of file. The four different file
types defined in WINNT.H are:</font></p>

<p><font size="2" face="ARIAL"><b>WINNT.H</b></font></p>

<pre><font size="2" face="COURIER">#define IMAGE_DOS_SIGNATURE             0x5A4D      // MZ
#define IMAGE_OS2_SIGNATURE             0x454E      // NE
#define IMAGE_OS2_SIGNATURE_LE          0x454C      // LE
#define IMAGE_NT_SIGNATURE              0x00004550  // PE00
</font></pre>

<p><font size="2" face="ARIAL">At first it seems curious that
Windows executable file types do not appear on this list. But
then, after a little investigation, the reason becomes clear:
There really is no difference between Windows executables and
OS/2 executables other than the operating system version
specification. Both operating systems share the same executable
file structure.</font></p>

<p><font size="2" face="ARIAL">Turning our attention back to the
Windows NT PE file format, we find that once we have the location
of the file signature, the PE file follows four bytes later. The
next macro identifies the PE file header:</font></p>

<pre><font size="2" face="COURIER">#define PEFHDROFFSET(a) ((LPVOID)((BYTE *)a +  \
    ((PIMAGE_DOS_HEADER)a)-&gt;e_lfanew + SIZE_OF_NT_SIGNATURE))
</font></pre>

<p><font size="2" face="ARIAL">The only difference between this
and the previous macro is that this one adds in the constant
SIZE_OF_NT_SIGNATURE. Sad to say, this constant is not defined in
WINNT.H.</font></p>

<p><font size="2" face="ARIAL">Now that we know the location of
the PE file header, we can examine the data in the header simply
by assigning this location to a structure, as in the following
example:</font></p>

<pre><font size="2" face="COURIER">PIMAGE_FILE_HEADER   pfh;

pfh = (PIMAGE_FILE_HEADER)PEFHDROFFSET (lpFile);
</font></pre>

<p><font size="2" face="ARIAL">In this example, <i>lpFile</i>
represents a pointer to the base of the memory-mapped executable
file, and therein lies the convenience of memory-mapped files. No
file I/O needs to be performed; simply dereference the pointer <i>pfh</i>
to access information in the file. The PE file header structure
is defined as:</font></p>

<p><font size="2" face="ARIAL"><b>WINNT.H</b></font></p>

<pre><font size="2" face="COURIER">typedef struct _IMAGE_FILE_HEADER {
    USHORT  Machine;
    USHORT  NumberOfSections;
    ULONG   TimeDateStamp;
    ULONG   PointerToSymbolTable;
    ULONG   NumberOfSymbols;
    USHORT  SizeOfOptionalHeader;
    USHORT  Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

#define IMAGE_SIZEOF_FILE_HEADER             20
</font></pre>

<p><font size="2" face="ARIAL">Notice that the size of the file
header structure is conveniently defined in the include file...</font></p>

<p><font size="2" face="ARIAL">The information in the PE file is
basically high-level information that is used by the system or
applications to determine how to treat the file. The first field
is used to indicate what type of machine the executable was built
for, such as the DEC速 Alpha, MIPS R4000, Intel速 x86, or some
other processor. The system uses this information to quickly
determine how to treat the file before going any further into the
rest of the file data.</font></p>

<p><font size="2" face="ARIAL">The <i>Characteristics</i> field
identifies specific characteristics about the file. For example,
consider how separate debug files are managed for an executable.
It is possible to strip debug information from a PE file and
store it in a debug file (.DBG) for use by debuggers. To do this,
a debugger needs to know whether to find the debug information in
a separate file or not and whether the information has been
stripped from the file or not. A debugger could find out by
drilling down into the executable file looking for debug
information. To save the debugger from having to search the file,
a file characteristic that indicates that the file has been
stripped (IMAGE_FILE_DEBUG_STRIPPED) was invented. Debuggers can
look in the PE file header to quickly determine whether the debug
information is present in the file or not.</font></p>

<p><font size="2" face="ARIAL">WINNT.H defines several other
flags that indicate file header information much the way the
example described above does. I'll leave it as an exercise for
the reader t o look up the flags to see if any of them are
interesting or not. They are located in WINNT.H immediately after
the <b>IMAGE_FILE_HEADER</b> structure described above.</font></p>

<p><font size="2" face="ARIAL">One other useful entry in the PE
file header structure is the <i>NumberOfSections</i> field. It
turns out that you need to know how many sections--more
specifically, how many section headers and section bodies--are in
the file in order to extract the information easily. Each section
header and section body is laid out sequentially in the file, so
the number of sections is necessary to determine where the
section headers and bodies end. The following function extracts
the number of sections from the PE file header:</font></p>

<pre><font size="2" face="COURIER">int   WINAPI NumOfSections (
    LPVOID    lpFile)
{
    /* Number of sections is indicated in file header. */
    return (int)((PIMAGE_FILE_HEADER)
                  PEFHDROFFSET (lpFile))-&gt;NumberOfSections);
}
</font></pre>

<p><font size="2" face="ARIAL">As you can see, the <b>PEFHDROFFSET</b>
and the other macros are pretty handy to have around.</font></p>

<h2><font size="2" face="ARIAL">PE Optional Header</font></h2>

<p><font size="2" face="ARIAL">The next 224 bytes in the
executable file make up the PE optional header. Though its name
is &quot;optional header,&quot; rest assured that this is not an
optional entry in PE executable files. A pointer to the optional
header is obtained with the <b>OPTHDROFFSET</b> macro:</font></p>

<pre><font size="2" face="COURIER">#define OPTHDROFFSET(a) ((LPVOID)((BYTE *)a                 + \
    ((PIMAGE_DOS_HEADER)a)-&gt;e_lfanew + SIZE_OF_NT_SIGNATURE + \
    sizeof (IMAGE_FILE_HEADER)))
</font></pre>

<p><font size="2" face="ARIAL">The optional header contains most
of the meaningful information about the executable image, such as
initial stack size, program entry point location, preferred base
address, operating system version, section alignment information,
and so forth. The <b>IMAGE_OPTIONAL_HEADER</b> structure
represents the optional header as follows:</font></p>

<p><font size="2" face="ARIAL"><b>WINNT.H</b></font></p>

<pre><font size="2" face="COURIER">typedef struct _IMAGE_OPTIONAL_HEADER {
    //
    // Standard fields.
    //
    USHORT  Magic;
    UCHAR   MajorLinkerVersion;
    UCHAR   MinorLinkerVersion;
    ULONG   SizeOfCode;
    ULONG   SizeOfInitializedData;
    ULONG   SizeOfUninitializedData;
    ULONG   AddressOfEntryPoint;
    ULONG   BaseOfCode;
    ULONG   BaseOfData;
    //
    // NT additional fields.
    //
    ULONG   ImageBase;
    ULONG   SectionAlignment;
    ULONG   FileAlignment;
    USHORT  MajorOperatingSystemVersion;
    USHORT  MinorOperatingSystemVersion;
    USHORT  MajorImageVersion;
    USHORT  MinorImageVersion;
    USHORT  MajorSubsystemVersion;
    USHORT  MinorSubsystemVersion;
    ULONG   Reserved1;
    ULONG   SizeOfImage;
    ULONG   SizeOfHeaders;
    ULONG   CheckSum;
    USHORT  Subsystem;
    USHORT  DllCharacteristics;
    ULONG   SizeOfStackReserve;
    ULONG   SizeOfStackCommit;
    ULONG   SizeOfHeapReserve;
    ULONG   SizeOfHeapCommit;
    ULONG   LoaderFlags;
    ULONG   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER, *PIMAGE_OPTIONAL_HEADER;
</font></pre>

<p><font size="2" face="ARIAL">As you can see, the list of fields
in this structure is rather lengthy. Rather than bore you with
descriptions of all of these fields, I'll simply discuss the
useful ones--that is, useful in the context of exploring the PE
file format.</font></p>

<h3><font size="2" face="ARIAL">Standard Fields</font></h3>

<p><font size="2" face="ARIAL">First, note that the structure is
divided into &quot;Standard fields&quot; and &quot;NT additional
fields.&quot; The standard fields are those common to the Common
Object File Format (COFF), which most UNIX executable files use.
Though the standard fields retain the names defined in COFF,
Windows NT actually uses some of them for different purposes that
would be better described with other names.</font></p>

<ul>
    <li><font size="2" face="ARIAL"><!--BULLET--> <i>Magic</i>. I was unable
        to track down what this field is used for.</font></li>
    <li><font size="2" face="ARIAL"><!--BULLET--> <i>MajorLinkerVersion</i>, <i>MinorLinkerVersion</i>.
        Indicates version of the linker that linked this image.</font></li>
    <li><font size="2" face="ARIAL"><!--BULLET--> <i>SizeOfCode</i>. Size of
        executable code.</font></li>
    <li><font size="2" face="ARIAL"><!--BULLET--> <i>SizeOfInitializedData</i>.
        Size of initialized data.</font></li>
    <li><font size="2" face="ARIAL"><!--BULLET--> <i>SizeOfUninitializedData</i>.
        Size of uninitialized data.</font></li>
    <li><font size="2" face="ARIAL"><!--BULLET--> <i>AddressOfEntryPoint</i>.
        Of the standard fields, the <i>AddressOfEntryPoint</i>
        field is the most interesting for the PE file format.
        This field indicates the location of the entry point for
        the application and, perhaps more importantly to system
        hackers, the location of the end of the Import Address
        Table (IAT). The following function demonstrates how to
        retrieve the entry point of a Windows NT executable image
        from the optional header. </font><dl>
            <dd>&nbsp;</dd>
            <dd><pre><font size="2" face="COURIER">LPVOID  WINAPI GetModuleEntryPoint (
    LPVOID    lpFile)
{
    PIMAGE_OPTIONAL_HEADER   poh;

    poh = (PIMAGE_OPTIONAL_HEADER)OPTHDROFFSET (lpFile);

    if (poh != NULL)
        return (LPVOID)poh-&gt;AddressOfEntryPoint;
    else
        return NULL;
}
</font></pre>
            </dd>
        </dl>
    </li>
    <li><font size="2" face="ARIAL"><!--BULLET--> <i>BaseOfCode</i>. Relative
        offset of code (&quot;.text&quot; section) in loaded
        image.</font></li>
    <li><font size="2" face="ARIAL"><!--BULLET--> <i>BaseOfData</i>. Relative
        offset of uninitialized data (&quot;.bss&quot; section)
        in loaded image. </font></li>
</ul>

<h3><font size="2" face="ARIAL">Windows NT Additional Fields</font></h3>

<p><font size="2" face="ARIAL">The additional fields added to the
Windows NT PE file format provide loader support for much of the
Windows NT-specific process behavior. Following is a summary of
these fields.</font></p>

<ul>
    <li><font size="2" face="ARIAL"><!--BULLET--> <i>ImageBase</i>. Preferred
        base address in the address space of a process to map the
        executable image to. The linker defaults to 0x00400000,
        but you can override the default with the <b>-BASE:
        linker</b> switch.</font></li>
    <li><font size="2" face="ARIAL"><!--BULLET--> <i>SectionAlignment</i>.
        Each section is loaded into the address space of a
        process sequentially, beginning at <i>ImageBase</i>. <i>SectionAlignment</i>
        dictates the minimum amount of space a section can occupy
        when loaded--that is, sections are aligned on <i>SectionAlignment</i>
        boundaries. </font><p><font size="2" face="ARIAL">Section
        alignment can be no less than the page size (currently
        4096 bytes on the <i>x</i>86 platform) and must be a
        multiple of the page size as dictated by the behavior of
        Windows NT's virtual memory manager. 4096 bytes is the <i>x</i>86
        linker default, but this can be set using the <b>-ALIGN:
        linker</b> switch.<br>
        </font></p>
    </li>
    <li><font size="2" face="ARIAL"><!--BULLET--> <i>FileAlignment</i>.
        Minimum granularity of chunks of information within the
        image file prior to loading. For example, the linker
        zero-pads a section body (raw data for a section) up to
        the nearest <i>FileAlignment</i> boundary in the file.
        This value is constrained to be a power of 2 between 512
        and 65,535. </font></li>
    <li><font size="2" face="ARIAL"><!--BULLET--> <i>MajorOperatingSystemVersion</i>.
        Indicates the major version of the Windows NT operating
        system.</font></li>
    <li><font size="2" face="ARIAL"><!--BULLET--> <i>MinorOperatingSystemVersion</i>.
        Indicates the minor version of the Windows NT operating
        system.</font></li>
    <li><font size="2" face="ARIAL"><!--BULLET--> <i>MajorImageVersion</i>.
        Used to indicate the major version number of the
        application.</font></li>
    <li><font size="2" face="ARIAL"><!--BULLET--> <i>MinorImageVersion</i>.
        Used to indicate the minor version number of the
        application.</font></li>
    <li><font size="2" face="ARIAL"><!--BULLET--> <i>MajorSubsystemVersion</i>.
        Indicates the Windows NT Win32 subsystem major version
        number.</font></li>
    <li><font size="2" face="ARIAL"><!--BULLET--> <i>MinorSubsystemVersion</i>.
        Indicates the Windows NT Win32 subsystem minor version
        number.</font></li>
    <li><font size="2" face="ARIAL"><!--BULLET--> <i>Reserved1</i>. Unknown
        purpose, currently not used by the system and set to zero
        by the linker. </font></li>
    <li><font size="2" face="ARIAL"><!--BULLET--> <i>SizeOfImage</i>.
        Indicates the amount of address space to reserve in the
        address space for the loaded executable image. This
        number is influenced greatly by <i>SectionAlignment</i>.
        For example, consider a system having a fixed page size
        of 4096 bytes. If you have an executable with 11
        sections, each less than 4096 bytes, aligned on a
        65,536-byte boundary, the <i>SizeOfImage</i> field would
        be set to 11 * 65,536 = 720,896 (176 pages). The same
        file linked with 4096-byte alignment would result in 11 *
        4096 = 45,056 (11 pages) for the <i>SizeOfImage</i>
        field. This is a simple example in which each section
        requires less than a page of memory. In reality, the
        linker determines the exact <i>SizeOfImage</i> by
        figuring each section individually. It first determines
        how many bytes the section requires, then it rounds up to
        the nearest page boundary, and finally it rounds page
        count to the nearest <i>SectionAlignment</i> boundary.
        The total is then the sum of each section's individual
        requirement.</font></li>
    <li><font size="2" face="ARIAL"><!--BULLET--> <i>SizeOfHeaders</i>. This
        field indicates how much space in the file is used for
        representing all the file headers, including the MS-DOS
        header, PE file header, PE optional header, and PE
        section headers. The section bodies begin at this
        location in the file.</font></li>
    <li><font size="2" face="ARIAL"><!--BULLET--> <i>CheckSum</i>. A checksum
        value is used to validate the executable file at load
        time. The value is set and verified by the linker. The
        algorithm used for creating these checksum values is
        proprietary information and will not be published.</font></li>
    <li><font size="2" face="ARIAL"><!--BULLET--> <i>Subsystem</i>. Field used
        to identify the target subsystem for this executable.
        Each of the possible subsystem values are listed in the
        WINNT.H file immediately after the <b>IMAGE_OPTIONAL_HEADER</b>
        structure.</font></li>
    <li><font size="2" face="ARIAL"><!--BULLET--> <i>DllCharacteristics</i>.
        Flags used to indicate if a DLL image includes entry
        points for process and thread initialization and
        termination.</font></li>
    <li><font size="2" face="ARIAL"><!--BULLET--> <i>SizeOfStackReserve</i>, <i>SizeOfStackCommit</i>,
        <i>SizeOfHeapReserve</i>, <i>S izeOfHeapCommit</i>. These
        fields control the amount of address space to reserve and
        commit for the stack and default heap. Both the stack and
        heap have default values of 1 page committed and 16 pages
        reserved. These values are set with the linker switches <b>-STACKSIZE:</b>
        and <b>-HEAPSIZE:</b>.</font></li>
    <li><font size="2" face="ARIAL"><!--BULLET--> <i>LoaderFlags</i>. Tells
        the loader whether to break on load, debug on load, or
        the default, which is to let things run normally.</font></li>
    <li><font size="2" face="ARIAL"><!--BULLET--> <i>NumberOfRvaAndSizes</i>.
        This field identifies the length of the <i>DataDirectory</i>
        array that follows. It is important to note that this
        field is used to identify the size of the array, not the
        number of valid entries in the array.</font></li>
    <li><font size="2" face="ARIAL"><!--BULLET--> <i>DataDirectory</i>. The
        data directory indicates where to find other important
        components of executable information in the file. It is
        really nothing more than an array of <b>IMAGE_DATA_DIRECTORY</b>
        structures that are located at the end of the optional
        header structure. The current PE file format defines 16
        possible data directories, 11 of which are now being
        used. </font></li>
</ul>

<h3><font size="2" face="ARIAL">Data Directories</font></h3>

<p><font size="2" face="ARIAL">As defined in WINNT.H, the data
directories are:</font></p>

<p><font size="2" face="ARIAL"><b>WINNT.H</b></font></p>

<pre><font size="2" face="COURIER">// Directory Entries

// Export Directory
#define IMAGE_DIRECTORY_ENTRY_EXPORT         0
// Import Directory
#define IMAGE_DIRECTORY_ENTRY_IMPORT         1
// Resource Directory
#define IMAGE_DIRECTORY_ENTRY_RESOURCE       2
// Exception Directory
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION      3
// Security Directory
#define IMAGE_DIRECTORY_ENTRY_SECURITY       4
// Base Relocation Table
#define IMAGE_DIRECTORY_ENTRY_BASERELOC      5
// Debug Directory
#define IMAGE_DIRECTORY_ENTRY_DEBUG          6
// Description String
#define IMAGE_DIRECTORY_ENTRY_COPYRIGHT      7
// Machine Value (MIPS GP)
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR      8
// TLS Directory
#define IMAGE_DIRECTORY_ENTRY_TLS            9
// Load Configuration Directory
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10
</font></pre>

<p><font size="2" face="ARIAL">Each data directory is basically a
structure defined as an <b>IMAGE_DATA_DIRECTORY</b>. And although
data directory entries themselves are the same, each specific
directory type is entirely unique. The definition of each defined
data directory is described in &quot;Predefined Sections&quot;
later in this article.</font></p>

<p><font size="2" face="ARIAL"><b>WINNT.H</b></font></p>

<pre><font size="2" face="COURIER">typedef struct _IMAGE_DATA_DIRECTORY {
    ULONG   VirtualAddress;
    ULONG   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;
</font></pre>

<p><font size="2" face="ARIAL">Each data directory entry
specifies the size and relative virtual address of the directory.
To locate a particular directory, you determine the relative
address from the data directory array in the optional header.
Then use the virtual address to determine which section the
directory is in. Once you determine which section contains the
directory, the section header for that section is then used to
find the exact file offset location of the data directory.</font></p>

<p><font size="2" face="ARIAL">So to get a data directory, you
first need to know about sections, which are described next. An
example of how to locate data directories immediately follows
this discussion.</font></p>

<h2><font size="2" face="ARIAL">PE File Sections</font></h2>

<p><font size="2" face="ARIAL">The PE file specification consists
of the headers defined so far and a generic object called a <i>section</i>.
Sections contain the content of the file, including code, data,
resources, and other executable information. Each section has a
header and a body (the raw data). Section headers are described
below, but section bodies lack a rigid file structure. They can
be organized in almost any way a linker wishes to organize them,
as long as the header is filled with enough information to be
able to decipher the data.</font></p>

<h3><font size="2" face="ARIAL">Section Headers</font></h3>

<p><font size="2" face="ARIAL">Section headers are located
sequentially right after the optional header in the PE file
format. Each section header is 40 bytes with no padding between
them. Section headers are defined as in the following structure:</font></p>

<p><font size="2" face="ARIAL"><b>WINNT.H</b></font></p>

<pre><font size="2" face="COURIER">#define IMAGE_SIZEOF_SHORT_NAME              8

typedef struct _IMAGE_SECTION_HEADER {
    UCHAR   Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
            ULONG   PhysicalAddress;
            ULONG   VirtualSize;
    } Misc;
    ULONG   VirtualAddress;
    ULONG   SizeOfRawData;
    ULONG   PointerToRawData;
    ULONG   PointerToRelocations;
    ULONG   PointerToLinenumbers;
    USHORT  NumberOfRelocations;
    USHORT  NumberOfLinenumbers;
    ULONG   Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;
</font></pre>

<p><font size="2" face="ARIAL">How do you go about getting
section header information for a particular section? Since
section headers are organized sequentially in no specific order,
section headers must be located by name. The following function
shows how to retrieve a section header from a PE image file given
the name of the section:</font></p>

<pre><font size="2" face="COURIER">BOOL    WINAPI GetSectionHdrByName (
    LPVOID                   lpFile,
    IMAGE_SECTION_HEADER     *sh,
    char                     *szSection)
{
    PIMAGE_SECTION_HEADER    psh;
    int                      nSections = NumOfSections (lpFile);
    int                      i;


    if ((psh = (PIMAGE_SECTION_HEADER)SECHDROFFSET (lpFile)) !=
         NULL)
        {
        /* find the section by name */
        for (i=0; i&lt;nSections; i++)
            {
            if (!strcmp (psh-&gt;Name, szSection))
                {
                /* copy data to header */
                CopyMemory ((LPVOID)sh,
                            (LPVOID)psh,
                            sizeof (IMAGE_SECTION_HEADER));
                return TRUE;
                }
            else
                psh++;
            }
        }

    return FALSE;
}
</font></pre>

<p><font size="2" face="ARIAL">The function simply locates the
first section header via the <b>SECHDROFFSET</b> macro. Then the
function loops through each section, comparing each section's
name with the name of the section it's looking for, until it
finds the right one. When the section is found, the function
copies the data from the memory-mapped file to the structure
passed in to the function. The fields of the <b>IMAGE_SECTION_HEADER</b>
structure can then be accessed directly from the structure.</font></p>

<h3><font size="2" face="ARIAL">Section Header Fields</font></h3>

<ul>
    <li><font size="2" face="ARIAL"><!--BULLET--> <i>Name</i>. Each section
        header has a <i>name</i> field up to eight characters
        long, for which the first character must be a period.</font></li>
    <li><font size="2" face="ARIAL"><!--BULLET--> <i>PhysicalAddress </i>or<i>
        VirtualSize</i>. The second field is a union field that
        is not currently used.</font></li>
    <li><font size="2" face="ARIAL"><!--BULLET--> <i>VirtualAddress</i>. This
        field identifies the virtual address in the process's
        address space to which to load the section. The actual
        address is created by taking the value of this field and
        adding it to the <i>ImageBase</i> virtual address in the
        optional header structure. Keep in mind, though, that if
        this image file represents a DLL, there is no guarantee
        that the DLL will be loaded to the <i>ImageBase</i>
        location requested. So once the file is loaded into a
        process, the actual <i>ImageBase</i> value should be
        verified programmatically using <b>GetModuleHandle</b>.</font></li>
    <li><font size="2" face="ARIAL"><!--BULLET--> <i>SizeOfRawData</i>. This
        field indicates the <i>FileAlignment</i>-relative size of
        the section body. The actual size of the section body
        will be less than or equal to a multiple of <i>FileAlignment</i>
        in the file. Once the image is loaded into a process's
        address space, the size of the section body becomes less
        than or equal to a multiple of <i>SectionAlignment</i>.</font></li>
    <li><font size="2" face="ARIAL"><!--BULLET--> <i>PointerToRawData</i>.
        This is an offset to the location of the section body in
        the file.</font></li>
    <li><font size="2" face="ARIAL"><!--BULLET--> <i>PointerToRelocations</i>,
        <i>PointerToLinenumbers</i>, <i>NumberOfRelocations</i>, <i>NumberOfLinenumbers</i>.
        None of these fi elds are used in the PE file format.</font></li>
    <li><font size="2" face="ARIAL"><!--BULLET--> <i>Characteristics</i>.
        Defines the section characteristics. These values are
        found both in WINNT.H and in the Portable Executable
        Format specification located on this CD. </font></li>
</ul>

<table border="1" cellpadding="5" cellspacing="0" width="87%">
    <tr>
        <td valign="top" bgcolor="#DDDDDD"><font size="2" face="Arial"><b>Value</b></font></td>
        <td valign="top" bgcolor="#DDDDDD"><font size="2" face="Arial"><b>Definition</b></font></td>
    </tr>
    <tr>
        <td bgcolor="#DDDDDD">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" bgcolor="#DDDDDD"><font size="2" face="Arial">0x00000020</font></td>
        <td valign="top" bgcolor="#DDDDDD"><font size="2" face="Arial">Code section</font></td>
    </tr>
    <tr>
        <td bgcolor="#DDDDDD">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" bgcolor="#DDDDDD"><font size="2" face="Arial">0x00000040</font></td>
        <td valign="top" bgcolor="#DDDDDD"><font size="2" face="Arial">Initialized data section</font></td>
    </tr>
    <tr>
        <td bgcolor="#DDDDDD">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" bgcolor="#DDDDDD"><font size="2" face="Arial">0x00000080</font></td>
        <td valign="top" bgcolor="#DDDDDD"><font size="2" face="Arial">Uninitialized data section</font></td>
    </tr>
    <tr>
        <td bgcolor="#DDDDDD">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" bgcolor="#DDDDDD"><font size="2" face="Arial">0x04000000</font></td>
        <td valign="top" bgcolor="#DDDDDD"><font size="2" face="Arial">Section cannot be cached</font></td>
    </tr>
    <tr>
        <td bgcolor="#DDDDDD">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" bgcolor="#DDDDDD"><font size="2" face="Arial">0x08000000</font></td>
        <td valign="top" bgcolor="#DDDDDD"><font size="2" face="Arial">Section is not pageable</font></td>
    </tr>
    <tr>
        <td bgcolor="#DDDDDD">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" bgcolor="#DDDDDD"><font size="2" face="Arial">0x10000000</font></td>
        <td valign="top" bgcolor="#DDDDDD"><font size="2" face="Arial">Section is shared</font></td>
    </tr>
    <tr>
        <td bgcolor="#DDDDDD">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" bgcolor="#DDDDDD"><font size="2" face="Arial">0x20000000</font></td>
        <td valign="top" bgcolor="#DDDDDD"><font size="2" face="Arial">Executable section</font></td>
    </tr>
    <tr>
        <td bgcolor="#DDDDDD">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" bgcolor="#DDDDDD"><font size="2" face="Arial">0x40000000</font></td>
        <td valign="top" bgcolor="#DDDDDD"><font size="2" face="Arial">Readable section</font></td>
    </tr>
    <tr>
        <td bgcolor="#DDDDDD">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" bgcolor="#DDDDDD"><font size="2" face="Arial">0x80000000</font></td>
        <td valign="top" bgcolor="#DDDDDD"><font size="2" face="Arial">Writable section</font></td>
    </tr>
</table>

<h3><font size="2" face="ARIAL">Locating Data Directories</font></h3>

<p><font size="2" face="ARIAL">Data directories exist within the
body of their corresponding data section. Typically, data
directories are the first structure within the section body, but
not out of necessity. For that reason, you need to retrieve
information from both the section header and optional header to
locate a specific data directory.</font></p>

<p><font size="2" face="ARIAL">To make this process easier, the
following function was written to locate the data directory for
any of the directories defined in WINNT.H:</font></p>

<pre><font size="2" face="COURIER">LPVOID  WINAPI ImageDirectoryOffset (
        LPVOID    lpFile,
        DWORD     dwIMAGE_DIRECTORY)
{
    PIMAGE_OPTIONAL_HEADER   poh;
    PIMAGE_SECTION_HEADER    psh;
    int                      nSections = NumOfSections (lpFile);
    int                      i = 0;
    LPVOID                   VAImageDir;

    /* Must be 0 thru (NumberOfRvaAndSizes-1). */
    if (dwIMAGE_DIRECTORY &gt;= poh-&gt;NumberOfRvaAndSizes)
        return NULL;

    /* Retrieve offsets to optional and section headers. */
    poh = (PIMAGE_OPTIONAL_HEADER)OPTHDROFFSET (lpFile);
    psh = (PIMAGE_SECTION_HEADER)SECHDROFFSET (lpFile);

    /* Locate image directory's relative virtual address. */
    VAImageDir = (LPVOID)poh-&gt;DataDirectory
                       [dwIMAGE_DIRECTORY].VirtualAddress;

    /* Locate section containing image directory. */
    while (i++&lt;nSections)
        {
        if (psh-&gt;VirtualAddress &lt;= (DWORD)VAImageDir &amp;&amp;
            psh-&gt;VirtualAddress +
                 psh-&gt;SizeOfRawData &gt; (DWORD)VAImageDir)
            break;
        psh++;
        }

    if (i &gt; nSections)
        return NULL;

    /* Return image import directory offset. */
    return (LPVOID)(((int)lpFile +
                     (int)VAImageDir. psh-&gt;VirtualAddress) +
                    (int)psh-&gt;PointerToRawData);
}
</font></pre>

<p><font size="2" face="ARIAL">The function begins by validating
the requested data directory entry number. Then it retrieves
pointers to the optional header and first section header. From
the optional header, the function determines the data directory's
virtual address, and it uses this value to determine within which
section body the data directory is located. Once the appropriate
section body has been identified, the specific location of the
data directory is found by translating the relative virtual
address of the data directory to a specific address into the
file.</font></p>

<h3><font size="2" face="ARIAL">Predefined Sections</font></h3>

<p><font size="2" face="ARIAL">An application for Windows NT
typically has the nine predefined sections named .text, .bss,
.rdata, .data, .rsrc, .edata, .idata, .pdata, and .debug. Some
applications do not need all of these sections, while others may
define still more sections to suit their specific needs. This
behavior is similar to code and data segments in MS-DOS and
Windows version 3.1. In fact, the way an application defines a
unique section is by using the standard compiler directives for
naming code and data segments or by using the name segment
compiler option <b>-NT</b>--exactly the same way in which
applications defined unique code and data segments in Windows
version 3.1.</font></p>

<p><font size="2" face="ARIAL">The following is a discussion of
some of the more interesting sections common to typical Windows
NT PE files.</font></p>

<h4><font size="2" face="ARIAL">Executable code section, .text</font></h4>

<p><font size="2" face="ARIAL">One difference between Windows
version 3.1 and Windows NT is that the default behavior combines
all code segments (as they are referred to in Windows version
3.1) into a single section called &quot;.text&quot; in Windows
NT. Since Windows NT uses a page-based virtual memory management
system, there is no advantage to separating code into distinct
code segments. Consequently, having one large code section is
easier to manage for both the operating system and the
application developer.</font></p>

<p><font size="2" face="ARIAL">The .text section also contains
the entry point mentioned earlier. The IAT also lives in the
.text section immediately before the module entry point. (The
IAT's presence in the .text section makes sense because the table
is really a series of jump instructions, for which the specific
location to jump to is the fixed-up address.) When Windows NT
executable images are loaded into a process's address space, the
IAT is fixed up with the location of each imported function's
physical address. In order to find the IAT in the .text section,
the loader simply locates the module entry point and relies on
the fact that the IAT occurs immediately before the entry point.
And since each entry is the same size, it is easy to walk
backward in the table to find its beginning.</font></p>

<h4><font size="2" face="ARIAL">Data sections, .bss, .rdata,
.data</font></h4>

<p><font size="2" face="ARIAL">The .bss section represents
uninitialized data for the application, including all variables
declared as static within a function or source module.</font></p>

<p><font size="2" face="ARIAL">The .rdata section represents
read-only data, such as literal strings, constants, and debug
directory information.</font></p>

<p><font size="2" face="ARIAL">All other variables (except
automatic variables, which appear on the stack) are stored in the
.data section. Basically, these are application or module global
variables.</font></p>

<h4><font size="2" face="ARIAL">Resources section, .rsrc</font></h4>

<p><font size="2" face="ARIAL">The .rsrc section contains
resource information for a module. It begins with a resource
directory structure like most other sections, but this section's
data is further structured into a resource tree. The <b>IMAGE_RESOURCE_DIRECTORY</b>,
shown below, forms the root and nodes of the tree.</font></p>

<p><font size="2" face="ARIAL"><b>WINNT.H</b></font></p>

<pre><font size="2" face="COURIER">typedef struct _IMAGE_RESOURCE_DIRECTORY {
    ULONG   Characteristics;
    ULONG   TimeDateStamp;
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    USHORT  NumberOfNamedEntries;
    USHORT  NumberOfIdEntries;
} IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;
</font></pre>

<p><font size="2" face="ARIAL">Looking at the directory
structure, you won't find any pointer to the next nodes. Instead,
there are two fields, <i>NumberOfNamedEntries</i> and <i>NumberOfIdEntries</i>,
used to indicate how many entries are attached to the directory.
By <i>attached</i>, I mean the directory entries follow
immediately after the directory in the section data. The named
entries appear first in ascending alphabetical order, followed by
the ID entries in ascending numerical order.</font></p>

<p><font size="2" face="ARIAL">A directory entry consists of two
fields, as described in the following <b>IMAGE_RESOURCE_DIRECTORY_ENTRY</b>
structure:</font></p>

<p><font size="2" face="ARIAL"><b>WINNT.H</b></font></p>

<pre><font size="2" face="COURIER">typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {
    ULONG   Name;
    ULONG   OffsetToData;
} IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;
</font></pre>

<p><font size="2" face="ARIAL">The two fields are used for
different things depending on the level of the tree. The <i>Name</i>
field is used to identify either a type of resource, a resource
name, or a resource's language ID. The <i>OffsetToData</i> field
is always used to point to a sibling in the tree, either a
directory node or a leaf node.</font></p>

<p><font size="2" face="ARIAL">Leaf nodes are the lowest node in
the resource tree. They define the size and location of the
actual resource data. Each leaf node is represented using the
following <b>IMAGE_RESOURCE_DATA_ENTRY</b> structure:</font></p>

<p><font size="2" face="ARIAL"><b>WINNT.H</b></font></p>

<pre><font size="2" face="COURIER">typedef struct _IMAGE_RESOURCE_DATA_ENTRY {
    ULONG   OffsetToData;
    ULONG   Size;
    ULONG   CodePage;
    ULONG   Reserved;
} IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;
</font></pre>

<p><font size="2" face="ARIAL">The two fields <i>OffsetToData</i>
and <i>Size</i> indicate the location and size of the actual
resource data. Since this information is used primarily by
functions once the application has been loaded, it makes more
sense to make the <i>OffsetToData</i> field a relative virtual
address. This is precisely the case. Interestingly enough, all
other offsets, such as pointers from directory entries to other
directories, are offsets relative to the location of the root
node.</font></p>

<p><font size="2" face="ARIAL">To make all of this a little
clearer, consider Figure 2.</font></p>

<p><font size="2" face="ARIAL"><img src="pef2034c.gif" alt="[PE ResourceTree 12787 bytes ]" width="788" height="587"></font></p>

<p><font size="2" face="ARIAL"><b>Figure 2. A simple resource
tree structure</b></font></p>

<p><font size="2" face="ARIAL">Figure 2 depicts a very simple
resource tree containing only two resource objects, a menu, and a
string table. Further, the menu and string table have only one
item each. Yet, you can see how complicated the resource tree
becomes--even with as few resources as this.</font></p>

<p><font size="2" face="ARIAL">At the root of the tree, the first
directory has one entry for each type of resource the file
contains, no matter how many of each type there are. In Figure 2,
there are two entries identified by the root, one for the menu
and one for the string table. If there had been one or more
dialog resources included in the file, the root node would have
had one more entry and, consequently, another branch for the
dialog resources.</font></p>

<p><font size="2" face="ARIAL">The basic resource types are
identified in the file WINUSER.H and are listed below:</font></p>

<p><font size="2" face="ARIAL"><b>WINUSER.H</b></font></p>

<pre><font size="2" face="COURIER">/*
 * Predefined Resource Types
 */
#define RT_CURSOR           MAKEINTRESOURCE(1)
#define RT_BITMAP           MAKEINTRESOURCE(2)
#define RT_ICON             MAKEINTRESOURCE(3)
#define RT_MENU             MAKEINTRESOURCE(4)
#define RT_DIALOG           MAKEINTRESOURCE(5)
#define RT_STRING           MAKEINTRESOURCE(6)
#define RT_FONTDIR          MAKEINTRESOURCE(7)
#define RT_FONT             MAKEINTRESOURCE(8)
#define RT_ACCELERATOR      MAKEINTRESOURCE(9)
#define RT_RCDATA           MAKEINTRESOURCE(10)
#define RT_MESSAGETABLE     MAKEINTRESOURCE(11)
</font></pre>

<p><font size="2" face="ARIAL">At the top level of the tree, the
MAKEINTRESOURCE values listed above are placed in the <i>Name</i>
field of each type entry, identifying the different resources by
type.</font></p>

<p><font size="2" face="ARIAL">Each of the entries in the root
directory points to a sibling node in the second level of the
tree. These nodes are directories, too, each having their own
entries. At this level, the directories are used to identify the
name of each resource within a given type. If you had multiple
menus defined in your application, there would be an entry for
each one here at the second level of the tree.</font></p>

<p><font size="2" face="ARIAL">As you are probably already aware,
resources can be identified by name or by integer. They are
distinguished in this level of the tree via the <i>Name</i> field
in the directory structure. If the most significant bit of the <i>Name</i>
field is set, the other 31 bits are used as an offset to an <b>IMAGE_RESOURCE_DIR_STRING_U</b>
structure.</font></p>

<p><font size="2" face="ARIAL"><b>WINNT.H</b></font></p>

<pre><font size="2" face="COURIER">typedef struct _IMAGE_RESOURCE_DIR_STRING_U {
    USHORT  Length;
    WCHAR   NameString[ 1 ];
} IMAGE_RESOURCE_DIR_STRING_U, *PIMAGE_RESOURCE_DIR_STRING_U;
</font></pre>

<p><font size="2" face="ARIAL">This structure is simply a 2-byte <i>Length</i>
field followed by <i>Length</i> UNICODE characters.</font></p>

<p><font size="2" face="ARIAL">On the other hand, if the most
significant bit of the <i>Name</i> field is clear, the lower 31
bits are used to represent the integer ID of the resource. Figure
2 shows the menu resource as a named resource and the string
table as an ID resource.</font></p>

<p><font size="2" face="ARIAL">If there were two menu resources,
one identified by name and one by resource, they would both have
entries immediately after the menu resource directory. The named
resource entry would appear first, followed by the
integer-identified resource. The directory fields <i>NumberOfNamedEntries</i>
and <i>NumberOfIdEntries</i> would each contain the value 1,
indicating the presence of one entry.</font></p>

<p><font size="2" face="ARIAL">Below level two, the resource tree
does not branch out any further. Level one branches into
directories representing each type of resource, and level two
branches into directories representing each resource by
identifier. Level three maps a one-to-one correspondence between
the individually identified resources and their respective
language IDs. To indicate the language ID of a resource, the <i>Name</i>
field of the directory entry structure is used to indicate both
the primary language and sublanguage ID for the resource. For the
value 0x0409, 0x09 represents the primary language as
LANG_ENGLISH, and 0x04 is defined as SUBLANG_ENGLISH_CAN for the
sublanguage. The entire set of language IDs is defined in the
file WINNT.H.</font></p>

<p><font size="2" face="ARIAL">Since the language ID node is the
last directory node in the tree, the <i>OffsetToData</i> field in
the entry structure is an offset to a leaf node--the <b>IMAGE_RESOURCE_DATA_ENTRY</b>
structure mentioned earlier.</font></p>

<p><font size="2" face="ARIAL">Referring back to Figure 2, you
can see one data entry node for each language directory entry.
This node simply indicates the size of the resource data and the
relative virtual address where the resource data is located.</font></p>

<p><font size="2" face="ARIAL">One advantage to having so much
structure to the resource data section, .rsrc, is that you can
glean a great deal of information from the section without
accessing the resources themselves. For example, you can find out
how many there are of each type of resource, what resources--if
any--use a particular language ID, whether a particular resource
exists or not, and the size of individual types of resources. To
demonstrate how to make use of this information, the following
function shows how to determine the different types of resources
a file includes:</font></p>

<pre><font size="2" face="COURIER">int     WINAPI GetListOfResourceTypes (
    LPVOID    lpFile,
    HANDLE    hHeap,
    char      **pszResTypes)
{
    PIMAGE_RESOURCE_DIRECTORY          prdRoot;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY    prde;
    char                               *pMem;
    int                                nCnt, i;


    /* Get root directory of resource tree. */
    if ((prdRoot = PIMAGE_RESOURCE_DIRECTORY)ImageDirectoryOffset
           (lpFile, IMAGE_DIRECTORY_ENTRY_RESOURCE)) == NULL)
        return 0;

    /* Allocate enough space from heap to cover all types. */
    nCnt = prdRoot-&gt;NumberOfIdEntries * (MAXRESOURCENAME + 1);
    *pszResTypes = (char *)HeapAlloc (hHeap,
                                      HEAP_ZERO_MEMORY,
                                      nCnt);
    if ((pMem = *pszResTypes) == NULL)
        return 0;

    /* Set pointer to first resource type entry. */
    prde = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)((DWORD)prdRoot +
               sizeof (IMAGE_RESOURCE_DIRECTORY));

    /* Loop through all resource directory entry types. */
    for (i=0; i&lt;prdRoot-&gt;NumberOfIdEntries; i++)
        {
        if (LoadString (hDll, prde-&gt;Name, pMem, MAXRESOURCENAME))
            pMem += strlen (pMem) + 1;

        prde++;
        }

    return nCnt;
}
</font></pre>

<p><font size="2" face="ARIAL">This function returns a list of
resource type names in the string identified by <i>pszResTypes</i>.
Notice that, at the heart of this function, <b>LoadString</b> is
called using the <i>Name</i> field of each resource type
directory entry as the string ID.of resource type strings whose
IDs are defined the same as the type specifiers in the directory
entries.It would be rather easy to expand on these functions or
write new functions that extracted other information from this
section.</font></p>

<h4><font size="2" face="ARIAL">Export data section, .edata</font></h4>

<p><font size="2" face="ARIAL">The .edata section contains export
data for an application or DLL. When present, this section
contains an export directory for getting to the export
information.</font></p>

<p><font size="2" face="ARIAL"><b>WINNT.H</b></font></p>

<pre><font size="2" face="COURIER">typedef struct _IMAGE_EXPORT_DIRECTORY {
    ULONG   Characteristics;
    ULONG   TimeDateStamp;
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    ULONG   Name;
    ULONG   Base;
    ULONG   NumberOfFunctions;
    ULONG   NumberOfNames;
    PULONG  *AddressOfFunctions;
    PULONG  *AddressOfNames;
    PUSHORT *AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;
</font></pre>

<p><font size="2" face="ARIAL">The <i>Name</i> field in the
export directory identifies the name of the executable module. <i>NumberOfFunctions</i>
and <i>NumberOfNames</i> fields indicate how many functions and
function names are being exported from the module.</font></p>

<p><font size="2" face="ARIAL">The <i>AddressOfFunctions</i>
field is an offset to a list of exported function entry points.
The <i>AddressOfNames</i> field is the address of an offset to
the beginning of a null-separated list of exported function
names. <i>AddressOfNameOrdinals</i> is an offset to a list of
ordinal values (each 2 bytes long) for the same exported
functions.</font></p>

<p><font size="2" face="ARIAL">The three <i>AddressOf...</i>
fields are relative virtual addresses into the address space of a
process once the module has been loaded. Once the module is
loaded, the relative virtual address should be added to the
module base address to get the exact location in the address
space of the process. Before the file is loaded, however, the
address can be determined by subtracting the section header
virtual address (<i>VirtualAddress</i>) from the given field
address, adding the section body offset (<i>PointerToRawData</i>)
to the result, and then using this value as an offset into the
image file. The following example illustrates this technique:</font></p>

<pre><font size="2" face="COURIER">int  WINAPI GetExportFunctionNames (
    LPVOID    lpFile,
    HANDLE    hHeap,
    char      **pszFunctions)
{
    IMAGE_SECTION_HEADER       sh;
    PIMAGE_EXPORT_DIRECTORY    ped;
    char                       *pNames, *pCnt;
    int                        i, nCnt;

    /* Get section header and pointer to data directory
       for .edata section. */
    if ((ped = (PIMAGE_EXPORT_DIRECTORY)ImageDirectoryOffset
            (lpFile, IMAGE_DIRECTORY_ENTRY_EXPORT)) == NULL)
        return 0;
    GetSectionHdrByName (lpFile, &amp;sh, &quot;.edata&quot;);

    /* Determine the offset of the export function names. */
    pNames = (char *)(*(int *)((int)ped-&gt;AddressOfNames -
                               (int)sh.VirtualAddress   +
                               (int)sh.PointerToRawData +
                               (int)lpFile)    -
                      (int)sh.VirtualAddress   +
                      (int)sh.PointerToRawData +
                      (int)lpFile);

    /* Figure out how much memory to allocate for all strings. */
    pCnt = pNames;
    for (i=0; i&lt;(int)ped-&gt;NumberOfNames; i++)
        while (*pCnt++);
    nCnt = (int)(pCnt. pNames);

    /* Allocate memory off heap for function names. */
    *pszFunctions = HeapAlloc (hHeap, HEAP_ZERO_MEMORY, nCnt);

    /* Copy all strings to buffer. */
    CopyMemory ((LPVOID)*pszFunctions, (LPVOID)pNames, nCnt);

    return nCnt;
}
</font></pre>

<p><font size="2" face="ARIAL">Notice that in this function the
variable <i>pNames</i> is assigned by determining first the
address of the offset and then the actual offset location. Both
the address of the offset and the offset itself are relative
virtual addresses and must be translated before being used, as
the function demonstrates. You could write a similar function to
determine the ordinal values or entry points of the functions.</font></p>

<h4><font size="2" face="ARIAL">Import data section, .idata</font></h4>

<p><font size="2" face="ARIAL">The .idata section is import data,
including the import directory and import address name table.
Although an IMAGE_DIRECTORY_ENTRY_IMPORT directory is defined, no
corresponding import directory structure is included in the file
WINNT.H. Instead, there are several other structures called
IMAGE_IMPORT_BY_NAME, IMAGE_THUNK_DATA, and
IMAGE_IMPORT_DESCRIPTOR. Personally, I couldn't make heads or
tails of how these structures are supposed to correlate to the
.idata section, so I spent several hours deciphering the .idata
section body and came up with a much simpler structure. I named
this structure <b>IMAGE_IMPORT_MODULE_DIRECTORY</b>.</font></p>

<pre><font size="2" face="COURIER">typedef struct tagImportDirectory
    {
    DWORD    dwRVAFunctionNameList;
    DWORD    dwUseless1;
    DWORD    dwUseless2;
    DWORD    dwRVAModuleName;
    DWORD    dwRVAFunctionAddressList;
    }IMAGE_IMPORT_MODULE_DIRECTORY,
     * PIMAGE_IMPORT_MODULE_DIRECTORY;
</font></pre>

<p><font size="2" face="ARIAL">Unlike the data directories of
other sections, this one repeats one after another for each
imported module in the file. Think of it as an entry in a list of
module data directories, rather than a data directory to the
entire section of data. Each entry is a directory to the import
information for a specific module.</font></p>

<p><font size="2" face="ARIAL">One of the fields in the <b>IMAGE_IMPORT_MODULE_DIRECTORY</b>
structure is <i>dwRVAModuleName</i>, a relative virtual address
pointing to the name of the module. There are also two <i>dwUseless</i>
parameters in the structure that serve as padding to keep the
structure aligned properly within the section. The PE file format
specification mentions something about import flags, a time/date
stamp, and major/minor versions, but these two fields remained
empty throughout my experimentation, so I still consider them
useless.</font></p>

<p><font size="2" face="ARIAL">Based on the definition of this
structure, you can retrieve the names of modules and all
functions in each module that are imported by an executable file.
The following function demonstrates how to retrieve all the
module names imported by a particular PE file:</font></p>

<pre><font size="2" face="COURIER">int  WINAPI GetImportModuleNames (
    LPVOID    lpFile,
    HANDLE    hHeap,
    char      **pszModules)
{
    PIMAGE_IMPORT_MODULE_DIRECTORY  pid;
    IMAGE_SECTION_HEADER            idsh;
    BYTE                            *pData;
    int                             nCnt = 0, nSize = 0, i;
    char                            *pModule[1024];
    char                            *psz;

    pid = (PIMAGE_IMPORT_MODULE_DIRECTORY)ImageDirectoryOffset
             (lpFile, IMAGE_DIRECTORY_ENTRY_IMPORT);
    pData = (BYTE *)pid;

    /* Locate section header for &quot;.idata&quot; section. */
    if (!GetSectionHdrByName (lpFile, &amp;idsh, &quot;.idata&quot;))
        return 0;

    /* Extract all import modules. */
    while (pid-&gt;dwRVAModuleName)
        {
        /* Allocate buffer for absolute string offsets. */
        pModule[nCnt] = (char *)(pData +
               (pid-&gt;dwRVAModuleName-idsh.VirtualAddress));
        nSize += strlen (pModule[nCnt]) + 1;

        /* Increment to the next import directory entry. */
        pid++;
        nCnt++;
        }

    /* Copy all strings to one chunk of heap memory. */
    *pszModules = HeapAlloc (hHeap, HEAP_ZERO_MEMORY, nSize);
    psz = *pszModules;
    for (i=0; i&lt;nCnt; i++)
        {
        strcpy (psz, pModule[i]);
        psz += strlen (psz) + 1;
        }

    return nCnt;
}
</font></pre>

<p><font size="2" face="ARIAL">The function is pretty
straightforward. However, one thing is worth pointing out--notice
the while loop. This loop is terminated when <i>pid-&gt;dwRVAModuleName</i>
is 0. Implied here is that at the end of the list of <b>IMAGE_IMPORT_MODULE_DIRECTORY</b>
structures is a null structure that has a value of 0 for at least
the <i>dwRVAModuleName</i> field. This is the behavior I observed
in my experimentation with the file and later confirmed in the PE
file format specification.</font></p>

<p><font size="2" face="ARIAL">The first field in the structure, <i>dwRVAFunctionNameList</i>,
is a relative virtual address to a list of relative virtual
addresses that each point to the function names within the file.
As shown in the following data, the module and function names of
all imported modules are listed in the .idata section data:</font></p>

<pre><font size="2" face="COURIER">E6A7 0000 F6A7 0000  08A8 0000 1AA8 0000  ................
28A8 0000 3CA8 0000  4CA8 0000 0000 0000  (...&lt;...L.......
0000 4765 744F 7065  6E46 696C 654E 616D  ..GetOpenFileNam
6541 0000 636F 6D64  6C67 3332 2E64 6C6C  eA..comdlg32.dll
0000 2500 4372 6561  7465 466F 6E74 496E  ..%.CreateFontIn
6469 7265 6374 4100  4744 4933 322E 646C  directA.GDI32.dl
6C00 A000 4765 7444  6576 6963 6543 6170  l...GetDeviceCap
7300 C600 4765 7453  746F 636B 4F62 6A65  s...GetStockObje
6374 0000 D500 4765  7454 6578 744D 6574  ct....GetTextMet
7269 6373 4100 1001  5365 6C65 6374 4F62  ricsA...SelectOb
6A65 6374 0000 1601  5365 7442 6B43 6F6C  ject....SetBkCol
6F72 0000 3501 5365  7454 6578 7443 6F6C  or..5.SetTextCol
6F72 0000 4501 5465  7874 4F75 7441 0000  or..E.TextOutA..
</font></pre>

<p><font size="2" face="ARIAL">This particular section represents
the beginning of the list of import module and function names. If
you begin examining the right section part of the data, you
should recognize the names of familiar Win32 API functions and
the module names they are found in. Reading from the top down,
you get <b>GetOpenFileNameA</b>, followed by the module name
COMDLG32.DLL. Shortly after that, you get <b>CreateFontIndirectA</b>,
followed by the module GDI32.DLL and then the functions <b>GetDeviceCaps</b>,
<b>GetStockObject</b>, <b>GetTextMetrics</b>, and so forth.</font></p>

<p><font size="2" face="ARIAL">This pattern repeats throughout
the .idata section. The first module name is COMDLG32.DLL and the
second is GDI32.DLL. Notice that only one function is imported
from the first module, while many functions are imported from the
second module. In both cases, the function names and the module
name to which they belong are ordered such that a function name
appears first, followed by the module name and then by the rest
of the function names, if any.</font></p>

<p><font size="2" face="ARIAL">The following function
demonstrates how to retrieve the function names for a specific
module:</font></p>

<pre><font size="2" face="COURIER">int  WINAPI GetImportFunctionNamesByModule (
    LPVOID    lpFile,
    HANDLE    hHeap,
    char      *pszModule,
    char      **pszFunctions)
{
    PIMAGE_IMPORT_MODULE_DIRECTORY  pid;
    IMAGE_SECTION_HEADER     idsh;
    DWORD                    dwBase;
    int                      nCnt = 0, nSize = 0;
    DWORD                    dwFunction;
    char                     *psz;


    /* Locate section header for &quot;.idata&quot; section. */
    if (!GetSectionHdrByName (lpFile, &amp;idsh, &quot;.idata&quot;))
        return 0;

    pid = (PIMAGE_IMPORT_MODULE_DIRECTORY)ImageDirectoryOffset
             (lpFile, IMAGE_DIRECTORY_ENTRY_IMPORT);

    dwBase = ((DWORD)pid. idsh.VirtualAddress);

    /* Find module's pid. */
    while (pid-&gt;dwRVAModuleName &amp;&amp;
           strcmp (pszModule,
                  (char *)(pid-&gt;dwRVAModuleName+dwBase)))
        pid++;

    /* Exit if the module is not found. */
    if (!pid-&gt;dwRVAModuleName)
        return 0;

    /* Count number of function names and length of strings. */
    dwFunction = pid-&gt;dwRVAFunctionNameList;
    while (dwFunction                      &amp;&amp;
           *(DWORD *)(dwFunction + dwBase) &amp;&amp;
           *(char *)((*(DWORD *)(dwFunction + dwBase)) +
            dwBase+2))
        {
        nSize += strlen ((char *)((*(DWORD *)(dwFunction +
             dwBase)) + dwBase+2)) + 1;
        dwFunction += 4;
        nCnt++;
        }

    /* Allocate memory off heap for function names. */
    *pszFunctions = HeapAlloc (hHeap, HEAP_ZERO_MEMORY, nSize);
    psz = *pszFunctions;

    /* Copy function names to memory pointer. */
    dwFunction = pid-&gt;dwRVAFunctionNameList;
    while (dwFunction                      &amp;&amp;
           *(DWORD *)(dwFunction + dwBase) &amp;&amp;
           *((char *)((*(DWORD *)(dwFunction + dwBase)) +
            dwBase+2)))
        {
        strcpy (psz, (char *)((*(DWORD *)(dwFunction + dwBase)) +
                dwBase+2));
        psz += strlen((char *)((*(DWORD *)(dwFunction + dwBase))+
                dwBase+2)) + 1;
        dwFunction += 4;
        }

    return nCnt;
}
</font></pre>

<p><font size="2" face="ARIAL">Like the <b>GetImportModuleNames</b>
function, this function relies on the end of each list of
information to have a zeroed entry. In this case, the list of
function names ends with one that is zero.</font></p>

<p><font size="2" face="ARIAL">The final field, <i>dwRVAFunctionAddressList</i>,
is a relative virtual address to a list of virtual addresses that
will be placed in the section data by the loader when the file is
loaded. Before the file is loaded, however, these virtual
addresses are replaced by relative virtual addresses that
correspond exactly to the list of function names. So before the
file is loaded, there are two identical lists of relative virtual
addresses pointing to imported function names.</font></p>

<h4><font size="2" face="ARIAL">Debug information section, .debug</font></h4>

<p><font size="2" face="ARIAL">Debug information is initially
placed in the .debug section. The PE file format also supports
separate debug files (normally identified with a .DBG extension)
as a means of collecting debug information in a central location.
The debug section contains the debug information, but the debug
directories live in the .rdata section mentioned earlier. Each of
those directories references debug information in the .debug
section. The debug directory structure is defined as an <b>IMAGE_DEBUG_DIRECTORY</b>,
as follows:</font></p>

<p><font size="2" face="ARIAL"><b>WINNT.H</b></font></p>

<pre><font size="2" face="COURIER">typedef struct _IMAGE_DEBUG_DIRECTORY {
    ULONG   Characteristics;
    ULONG   TimeDateStamp;
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    ULONG   Type;
    ULONG   SizeOfData;
    ULONG   AddressOfRawData;
    ULONG   PointerToRawData;
} IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY;
</font></pre>

<p><font size="2" face="ARIAL">The section is divided into
separate portions of data representing different types of debug
information. For each one there is a debug directory described
above. The different types of debug information are listed below:</font></p>

<p><font size="2" face="ARIAL"><b>WINNT.H</b></font></p>

<pre><font size="2" face="COURIER">#define IMAGE_DEBUG_TYPE_UNKNOWN          0
#define IMAGE_DEBUG_TYPE_COFF             1
#define IMAGE_DEBUG_TYPE_CODEVIEW         2
#define IMAGE_DEBUG_TYPE_FPO              3
#define IMAGE_DEBUG_TYPE_MISC             4
</font></pre>

<p><font size="2" face="ARIAL">The <i>Type</i> field in each
directory indicates which type of debug information the directory
represents. As you can see in the list above, the PE file format
supports many different types of debug information, as well as
some other informational fields. Of those, the <b>IMAGE_DEBUG_TYPE_MISC</b>
information is unique. This information was added to represent
miscellaneous information about the executable image that could
not be added to any of the more structured data sections in the
PE file format. This is the only location in the image file where
the image name is sure to appear. If an image exports
information, the export data section will also include the image
name.</font></p>

<p><font size="2" face="ARIAL">Each type of debug information has
its own header structure that defines its data. Each of these is
listed in the file WINNT.H. One nice thing about the <b>IMAGE_DEBUG_DIRECTORY</b>
structure is that it includes two fields that identify the debug
information. The first of these, <i>AddressOfRawData</i>, is the
relative virtual address of the data once the file is loaded. The
other, <i>PointerToRawData</i>, is an actual offset within the PE
file, where the data is located. This makes it easy to locate
specific debug information.</font></p>

<p><font size="2" face="ARIAL">As a last example, consider the
following function, which extracts the image name from the <b>IMAGE_DEBUG_MISC</b>
structure:</font></p>

<pre><font size="2" face="COURIER">int    WINAPI RetrieveModuleName (
    LPVOID    lpFile,
    HANDLE    hHeap,
    char      **pszModule)
{

    PIMAGE_DEBUG_DIRECTORY    pdd;
    PIMAGE_DEBUG_MISC         pdm = NULL;
    int                       nCnt;

    if (!(pdd = (PIMAGE_DEBUG_DIRECTORY)ImageDirectoryOffset
               (lpFile, IMAGE_DIRECTORY_ENTRY_DEBUG)))
        return 0;

    while (pdd-&gt;SizeOfData)
        {
        if (pdd-&gt;Type == IMAGE_DEBUG_TYPE_MISC)
            {
            pdm = (PIMAGE_DEBUG_MISC)
                ((DWORD)pdd-&gt;PointerToRawData + (DWORD)lpFile);

            nCnt = lstrlen (pdm-&gt;Data)*(pdm-&gt;Unicode?2:1);
            *pszModule = (char *)HeapAlloc (hHeap,
                                            HEAP_ZERO_MEMORY,
                                            nCnt+1;
            CopyMemory (*pszModule, pdm-&gt;Data, nCnt);

            break;
            }

        pdd ++;
        }

    if (pdm != NULL)
        return nCnt;
    else
        return 0;
}
</font></pre>

<p><font size="2" face="ARIAL">As you can see, the structure of
the debug directory makes it relatively easy to locate a specific
type of debug information. Once the <b>IMAGE_DEBUG_MISC</b>
structure is located, extracting the image name is as simple as
invoking the <b>CopyMemory</b> function.</font></p>

<p><font size="2" face="ARIAL">As mentioned above, debug
information can be stripped into separate .DBG files. The Windows
NT SDK includes a utility called REBASE.EXE that serves this
purpose. For example, in the following statement an executable
image named TEST.EXE is being stripped of debug information:</font></p>

<pre><font size="2" face="COURIER">rebase -b 40000 -x c:\samples\testdir test.exe
</font></pre>

<p><font size="2" face="ARIAL">The debug information is placed in
a new file called TEST.DBG and located in the path specified, in
this case c:\samples\testdir. The file begins with a single <b>IMAGE_SEPARATE_DEBUG_HEADER</b>
structure, followed by a copy of the section headers that exist
in the stripped executable image. Then the .debug section data
follows the section headers. So, right after the section headers
are the series of <b>IMAGE_DEBUG_DIRECTORY</b> structures and
their associated data. The debug information itself retains the
same structure as described above for normal image file debug
information.</font></p>

<p>&nbsp;</p>

<h5 align="right"><i><tt>Copyright 息 1996,1997 Johannes Plachy</tt></i></h5>

<h5 align="right"><i><tt>Last modified: <!--webbot
bot="Timestamp" startspan s-type="EDITED" s-format="%d.%m.%y" -->25.08.97<!--webbot
bot="Timestamp" i-checksum="13780" endspan --></tt></i></h5>
</body>
</html>

<img src="https://web.archive.org/web/20170301055357im_/http://geo.yahoo.com/serv?s=76000007&amp;t=933326888" width="1" height="1">
